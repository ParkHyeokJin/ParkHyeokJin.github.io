---
layout: post
title: 알고리즘 풀이(JAVA) - 백준 알고리즘_1436(브루트포스-영화감독 숌)
date:   2019-09-18 10:10:00
categories: Algorithm
category : Algorithm
comments: true 
---

### 브루트포스(brute-force)

- 브루트포스란?  
brute는 "짐승같은, 난폭한"이라는 뜻이고, brute-force는 "난폭한 힘, 폭력"이라는 뜻이다. 
암호학 용어로는 brute-force attack 또는 exhaustive key search, 우리말로는 노가다 또는 무차별 대입 공격이라 부른다. 
주로 암호학에서도 쓰이는 방법이긴 하지만, 굳이 암호학만의 문제는 아니고 다른 알고리즘 분야에서도 사용되고 있다. 
간단하게 말하자면 노가다와 다굴을 논리적이고 과학적으로 하는 방식.

- 특징  
조합 가능한 모든 문자열을 하나씩 대입해 보는 방식으로 문제를 푸는 것인데, 얼핏 무식하다고 생각할 수도 있겠지만 성공한다는 
가정 하에 항상 정확도 100%를 보장한다는 점에서, 자원만 충분하면 가장 무서운 방법이다. 
이론적으로 가능한 모든 경우의 수를 다 검색해 보는 것이라 정확도 100%가 항상 보장되니, 암호학에서는 가장 확실한 방법으로 통용되고 있다. 
무엇보다도 암호 확인 작업이라는 것이 손으로 입력한 문자열의 동일 여부를 확인하는 것이기 때문에, 
가능한 경우를 하나씩 대입하다 보면 언젠가는 암호를 찾을 수 있게 되는 식이다. 다만 정말로 그냥 무식하게 때려박는 건 아니고, 숫자만 섞어서 대입해보기 한번, 
로마자만 섞어서 대입해보기 한번 이런식으로 하다가 안되면 나머지를 순차적으로 하는 식으로 특정 규칙에 따라 우선순위를 두고 하기도 한다.

### 문제
문제 링크 : <https://www.acmicpc.net/problem/1436>

666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.  
조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때,  
반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.
하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.
종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.  
따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.  
일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.
숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.

### 풀이
풀이)  
- 반복문을 돌면서 문자열에 666이 들어 있을 경우 카운터를 체크 한다.
- 입력된 카운터 번째의 666이 들어있는 문자열을 찾았을 경우 출력후 반복문을 멈춘다.

### 소스
```java
import java.util.Scanner;

public class Baekjoon_1436 {
	public static void main(String[] args){
        try(Scanner scanner = new Scanner(System.in)){
        	int num = scanner.nextInt();
        	int cnt = 0;
        	int idx = 666;
        	while(true) {
        		if(String.valueOf(idx).contains("666")) {
        			cnt++;
        			if(cnt == num) {
        				System.out.println(idx);
        				break;
        			}
        		}
        		idx++;
        	}
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```